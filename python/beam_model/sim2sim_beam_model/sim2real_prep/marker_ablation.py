### Ablation study on the number of markers required to perform sim2sim cantilever residual learning.

import sys
sys.path.append('../')
sys.path.append('../../..')

import os
import time
import random
import numpy as np
import torch

import matplotlib.pyplot as plt

from env_cantilever import CantileverEnv3d

SEED = 42
torch.manual_seed(SEED)
np.random.seed(SEED)
random.seed(SEED)


def generate_target_sim (folder, weights, sim_steps=150, verbose=True):
    """
    Generate a target simulation for the cantilever, such that residual forces can be added onto an initial simulation to match the target simulation.

    The target simulation is generated by applying a constant force to the end of the cantilever, wait until steady state is reached, and then removing the force and observing the cantilever oscillate for sim_steps with a fixed timestep of dt=0.01s.

    Args:
        folder (str): folder to save the target simulation data to.
        weights (list [M]): list of weights to generate target simulations for.
        sim_steps (int): number of simulation steps to simulate for after removing the force.
        verbose (bool): whether to print out the time it takes to reach steady state.

    Returns:
        q_weights (list [W, sim_steps, N, 3]): list of target simulation displacements for each of the W weights.

        Stores the target simulation displacement and velocity data in the folder.
    """
    STEADY_STATE_THRESHOLD = 1e-5 # Velocity threshold for steady state preparation

    dt = 0.01
    steady_state_dt = 0.05
    options = {
        'density': 1.07e3,
        'youngs_modulus': 2.5e5,
        'poissons_ratio': 0.49,
        'state_force_parameters': [0, 0, -9.80709],
        'mesh_type': 'hex',
        'refinement': 1,
    }
    
    ### Generate for each weight
    q_weights = []
    for weight in weights:
        env = CantileverEnv3d(SEED, f"{folder}", options)

        ### Simulate until steady state is reached with a constant force applied to the end of the cantilever
        f_ext = torch.zeros_like(env.q0).reshape(-1, 3)
        for i in env.force_nodes:
            f_ext[i] = torch.tensor([0, 0, -weight*9.80709 / len(env.force_nodes)])
        f_ext = f_ext.reshape(-1)

        start_time = time.time()
        q, v = env.q0, env.v0
        for t in range(MAX_SIM_STEPS:=1000):
            q, v = env.forward(q, v, f_ext=f_ext, dt=steady_state_dt)

            if max(abs(v)) < STEADY_STATE_THRESHOLD:
                break
        assert t < MAX_SIM_STEPS - 1, "Steady state not reached!"

        if verbose:
            print(f"Steady state reached in {t*steady_state_dt:.2f}s taking {time.time() - start_time:.6f}s.")

        ### Simulate for 1.5s after removing the force
        q, v = env.q0, env.v0
        qs, vs = [q], [v]
        for t in range(sim_steps-1):
            q, v = env.forward(q, v, dt=dt)
            qs.append(q)
            vs.append(v)

        np.save(f"{folder}/target_sim/target_{weight:.4f}_q.npy", torch.stack(qs, dim=0).detach().numpy().reshape(sim_steps, -1, 3))
        np.save(f"{folder}/target_sim/target_{weight:.4f}_v.npy", torch.stack(vs, dim=0).detach().numpy().reshape(sim_steps, -1, 3))

        q_weights.append(torch.stack(qs, dim=0).detach().numpy().reshape(sim_steps, -1, 3))

    return np.stack(q_weights, axis=0)


def find_marker_ring (vertices, marker_ring_pos, tolerance=1e-3):
    """
    Given a list of normalized scalar positions/fractions along the length of the cantilever representing the marker rings, find the vertex indices of the corners on each cantilever face for each marker ring.

    Args:
        vertices (np.array [N, 3]): array of vertices for the cantilever.
        marker_ring_pos (list [M]): array of normalized scalar positions/fractions along the length of the cantilever representing the marker ring locations.

    Returns:
        marker_idx (list [4*M]): unordered array of vertex indices for markers on each face for all N marker rings.
    """
    # Convert marker_ring_pos to absolute positions along length of the cantilever
    marker_ring_pos = np.array(marker_ring_pos) * max(vertices[:,0])

    marker_idx = []
    for i, vert in enumerate(vertices):
        # Find the x-location of the marker ring
        if (abs(vert[0] - marker_ring_pos) < tolerance).any():
            # Check if the marker ring is on the left or right face of the cantilever
            if vert[1] == min(vertices[:,1]) or vert[1] == max(vertices[:,1]):
                # Check if the marker ring is on the bottom or top face of the cantilever
                if vert[2] == min(vertices[:,2]) or vert[2] == max(vertices[:,2]):
                    marker_idx.append(i)

    return marker_idx


def find_surface_markers (vertices):
    """
    Find the surface of the cantilever and return the vertex indices.

    Args:
        vertices (np.array [N, 3]): array of vertices for the cantilever.

    Returns:
        marker_idx (list): unordered array of vertex indices for markers on the beam surface.
    """
    # Simply look for the maximal or minimal coordinates in any dimension.
    marker_idx = []
    for i, vert in enumerate(vertices):
        if vert[0] == min(vertices[:,0]) or vert[0] == max(vertices[:,0]):
            marker_idx.append(i)
        elif vert[1] == min(vertices[:,1]) or vert[1] == max(vertices[:,1]):
            marker_idx.append(i)
        elif vert[2] == min(vertices[:,2]) or vert[2] == max(vertices[:,2]):
            marker_idx.append(i)

    return marker_idx


def opt_f_ext (initial_env, marker_idx, qs_target, dt=0.01, n_samples=1, folder="f_ext_opt"):
    """
    Optimize external forces to match the target simulation.

    Args:
        initial_env (CantileverEnv3d): initial environment to start the simulation from.
        qs_target (np.array [M, sim_steps, N, 3]): target simulation displacements for each of the M weights.
        dt (float): timestep to simulate with.
        n_samples (int): number of random initializations for force optimization.
        folder (str): folder to save the optimization results to.
    
    Returns:
        min_errs (list [N_SAMPLES]): list of minimum errors for each of the N_SAMPLES initializations.
    """
    n_weights = qs_target.shape[0]
    sim_steps = qs_target.shape[1]
    
    # Start with multiple initializations
    min_errs = []
    for s in range(n_samples):
        print(f"Sample {s+1}/{n_samples}")
        print('-'*10)

        fs_ext = torch.normal(0, 1e-4, [sim_steps-1, initial_env.q0.shape[0]], dtype=torch.float64, requires_grad=True)
        optimizer = torch.optim.Adam([fs_ext], lr=2e-3)
        scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.9)

        min_error = 1e10
        for epoch in range(MAX_EPOCHS:=500):
            optimizer.zero_grad()

            start_time = time.time()
            ### Simulate with external forces optimizable per timestep
            qs_initial = []
            for i in range(n_weights):
                # Start with first frame of the target simulation, but with zero velocity.
                q, v = torch.tensor(qs_target[i, 0].flatten()), initial_env.v0
                qs = [q]
                for t in range(sim_steps-1):
                    q, v = initial_env.forward(q, v, dt=dt, f_ext=fs_ext[t])
                    qs.append(q)

                qs_initial.append(torch.stack(qs, dim=0).reshape(sim_steps, -1, 3))
            
            qs_initial = torch.stack(qs_initial, dim=0)

            # Only compute loss using given marker indices
            loss = torch.abs((qs_initial[:, :, marker_idx] - torch.from_numpy(qs_target)[:, :, marker_idx])).mean()
            loss.backward()
            optimizer.step()
            scheduler.step()

            # Compute average error of full state of the cantilever
            error = torch.mean(torch.norm(qs_initial - torch.from_numpy(qs_target), dim=-1)).detach().numpy()

            # Store the best error
            if error < min_error:
                min_error = error

            if epoch % 50 == 0:
                ### Error Metrics
                # Compute the error of just the tip of the cantilever
                rel_error = torch.mean(torch.abs(qs_initial - torch.from_numpy(qs_target))[:, :, initial_env.force_nodes[0], 2] / torch.abs(torch.from_numpy(qs_target)[:, :, initial_env.force_nodes[0], 2]), dim=0)

                print(f"Epoch {epoch:03d}/{MAX_EPOCHS} in {time.time() - start_time:.4f}s at LR {scheduler.get_last_lr()[0]:.2e}: \tLoss {loss.item():.4e} \tRelative Error {100*rel_error.mean():.2f}% +- {100*rel_error.std():.2f}% \tError {error:.4e}m")

                # Plot the initial and target simulation
                _, ax = plt.subplots(figsize=(8, 6))
                ax.plot(np.arange(sim_steps) * dt, qs_initial.detach()[0, :, initial_env.force_nodes[0], 2], label="Initial")
                ax.plot(np.arange(sim_steps) * dt, qs_target[0, :, initial_env.force_nodes[0], 2], label="Target")
                ax.set_xlabel("Time (s)")
                ax.set_ylabel("Displacement (m)")
                ax.set_title(f"Epoch {epoch:03d}/{MAX_EPOCHS} in {time.time() - start_time:.4f}s: Relative Error {100*rel_error.mean():.2f}% +- {100*rel_error.std():.1f}% - Error {error:.4e}m")
                ax.legend()
                ax.grid()
                #plt.savefig(f"{folder}/epoch{epoch}.png")
                plt.savefig(f"{folder}/epoch.png")
                plt.close()

        min_errs.append(min_error)
    
    return min_errs

if __name__ == "__main__":
    ### Read command line arguments
    import argparse
    parser = argparse.ArgumentParser(description='Ablation study on the number of markers required to perform sim2sim cantilever residual learning.')
    parser.add_argument('--folder', type=str, default="marker_ablation", help='Folder to save data to.')
    parser.add_argument('--marker_allocation', type=str, default="marker_ring", choices=["marker_ring", "random"], help='How to ablate the markers, choices are "marker_ring" or "random".')
    parser.add_argument('--n_markers', nargs='*', type=int, default=None, help='Number of markers to consider for random sample. Used for parallelization of ablation study.')
    args = parser.parse_args()

    folder = args.folder
    # Choose how we want to ablate the markers, choices are "marker_ring" or "random"
    marker_allocation = args.marker_allocation
    n_markers = args.n_markers

    ### Initialize simulation details
    dt = 0.01
    sim_steps = 150
    weights = [0.05, ]
    #qs = generate_target_sim(folder, weights, sim_steps=sim_steps)

    # Check if the folder exists, otherwise we need to generate the target simulation data
    if not os.path.exists(folder):
        print("Target simulation data not generated, now generating...")
        os.makedirs(f"{folder}/target_sim")
        qs_target = generate_target_sim(folder, weights, sim_steps=sim_steps)
    
    else:
        print("Target simulation data already generated, now loading...")
        qs = []
        for weight in weights:
            q = np.load(f"{folder}/target_sim/target_{weight:.4f}_q.npy")
            qs.append(q)
        
        qs_target = np.stack(qs, axis=0)

    ### Initialize incorrect cantilever environment
    initial_options = {
        'density': 1.07e3,
        'youngs_modulus': 2e5,
        'poissons_ratio': 0.45,
        'state_force_parameters': [0, 0, -9.80709],
        'mesh_type': 'hex',
        'refinement': 1,
    }
    initial_env = CantileverEnv3d(SEED, f"{folder}", initial_options)


    if marker_allocation == "marker_ring":
        ### Increase number of marker rings gradually. With refinement 1, there are only 11 vertices in the x direction to use.
        # We choose to add marker rings from the tip of the beam to the base.
        marker_errors = []
        marker_ring_pos = []
        for i in range(11):
            marker_ring_pos.append(1 - (i / 10))
            print(f"Number of Marker Rings: {i+1}")
            
            ### Identify Marker Rings
            marker_idx = find_marker_ring(np.array(initial_env.q0).reshape(-1,3), marker_ring_pos)
            marker_pos = initial_env.q0.reshape(-1,3)[marker_idx]

            initial_env.display_mesh(initial_env.q0, f"{folder}/marker_rings{i}.png", extra_points=marker_pos)

            ### External Force Optimization to Match Target Simulation
            min_errors = opt_f_ext(initial_env, marker_idx, qs_target, dt=dt, n_samples=5, folder=folder)

            print('-'*10)
            print(f"Average minimum error: {np.mean(min_errors):.4e}m +- {np.std(min_errors):.2e}m")

            # Store marker errors
            marker_errors.append(min_errors)
            np.savetxt(f"{folder}/marker_errors.csv", np.stack(marker_errors, axis=0), delimiter=",")

    elif marker_allocation == "random":
        ### Randomly sample a certain amount of markers from the cantilever surface, and optimize external forces to match the target simulation.
        n_samples = 10

        ### Identify Surface Markers
        surface_markers = find_surface_markers(np.array(initial_env.q0).reshape(-1,3))
        if n_markers is None:
            n_markers = range(1, len(surface_markers)+1)

        marker_errors = []
        for i in n_markers:
            sample_errors = []

            # Since we do not want duplicates, we random sample without replacement into a set
            already_sampled = set()
            for j in range(n_samples):
                print(f"Number of Markers: {i} - Sample {j}")

                ### Randomly sample the markers
                marker_idx = random.sample(surface_markers, i)
                counter = 0
                # Always sort the tuple to make unique comparison. We do not care about permutations within the tuple.
                while tuple(sorted(marker_idx)) in already_sampled:
                    marker_idx = random.sample(surface_markers, i)
                    counter += 1
                    if counter > 1000:
                        raise RuntimeError("Cannot sample new marker_idx!")
                already_sampled.add(tuple(sorted(marker_idx)))
                marker_pos = initial_env.q0.reshape(-1,3)[marker_idx]

                initial_env.display_mesh(initial_env.q0, f"{folder}/random_markers{i}.png", extra_points=marker_pos)

                ## External Force Optimization to Match Target Simulation
                min_errors = opt_f_ext(initial_env, marker_idx, qs_target, dt=dt, n_samples=1, folder=folder)[0]

                sample_errors.append(min_errors)

            # Store marker errors
            sample_errors = np.stack(sample_errors, axis=0)
            marker_errors.append(sample_errors)
            
            print('-'*10)
            print(f"Average minimum error: {np.mean(sample_errors):.4e}m +- {np.std(sample_errors):.2e}m")
            print('-'*10)

            np.savetxt(f"{folder}/marker_errors.csv", np.stack(marker_errors, axis=0), delimiter=",")

    print("Successful Marker Ablation Study.")

